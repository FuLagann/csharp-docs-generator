"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const zlib = __importStar(require("zlib"));
const utils_1 = require("./utils");
const url_1 = require("url");
const http_manager_1 = require("./http-manager");
const config_variables_1 = require("./config-variables");
const core_1 = require("@actions/core");
class DownloadHttpClient {
    constructor() {
        this.downloadHttpManager = new http_manager_1.HttpManager(config_variables_1.getDownloadFileConcurrency());
    }
    /**
     * Gets a list of all artifacts that are in a specific container
     */
    listArtifacts() {
        return __awaiter(this, void 0, void 0, function* () {
            const artifactUrl = utils_1.getArtifactUrl();
            // use the first client from the httpManager, `keep-alive` is not used so the connection will close immediatly
            const client = this.downloadHttpManager.getClient(0);
            const requestOptions = utils_1.getRequestOptions('application/json');
            const rawResponse = yield client.get(artifactUrl, requestOptions);
            const body = yield rawResponse.readBody();
            if (utils_1.isSuccessStatusCode(rawResponse.message.statusCode) && body) {
                return JSON.parse(body);
            }
            // eslint-disable-next-line no-console
            console.log(rawResponse);
            throw new Error(`Unable to list artifacts for the run`);
        });
    }
    /**
     * Fetches a set of container items that describe the contents of an artifact
     * @param artifactName the name of the artifact
     * @param containerUrl the artifact container URL for the run
     */
    getContainerItems(artifactName, containerUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            // the itemPath search parameter controls which containers will be returned
            const resourceUrl = new url_1.URL(containerUrl);
            resourceUrl.searchParams.append('itemPath', artifactName);
            // no concurrent calls so a single httpClient without the http-manager is sufficient
            const client = utils_1.createHttpClient();
            // no keep-alive header, client disposal is not necessary
            const requestOptions = utils_1.getRequestOptions('application/json');
            const rawResponse = yield client.get(resourceUrl.toString(), requestOptions);
            const body = yield rawResponse.readBody();
            if (utils_1.isSuccessStatusCode(rawResponse.message.statusCode) && body) {
                return JSON.parse(body);
            }
            // eslint-disable-next-line no-console
            console.log(rawResponse);
            throw new Error(`Unable to get ContainersItems from ${resourceUrl}`);
        });
    }
    /**
     * Concurrently downloads all the files that are part of an artifact
     * @param downloadItems information about what items to download and where to save them
     */
    downloadSingleArtifact(downloadItems) {
        return __awaiter(this, void 0, void 0, function* () {
            const DOWNLOAD_CONCURRENCY = config_variables_1.getDownloadFileConcurrency();
            // limit the number of files downloaded at a single time
            const parallelDownloads = [...new Array(DOWNLOAD_CONCURRENCY).keys()];
            let downloadedFiles = 0;
            yield Promise.all(parallelDownloads.map((index) => __awaiter(this, void 0, void 0, function* () {
                while (downloadedFiles < downloadItems.length) {
                    const currentFileToDownload = downloadItems[downloadedFiles];
                    downloadedFiles += 1;
                    yield this.downloadIndividualFile(index, currentFileToDownload.sourceLocation, currentFileToDownload.targetPath);
                }
            })));
            // done downloading, safety dispose all connections
            this.downloadHttpManager.disposeAndReplaceAllClients();
        });
    }
    /**
     * Downloads an individual file
     * @param httpClientIndex the index of the http client that is used to make all of the calls
     * @param artifactLocation origin location where a file will be downloaded from
     * @param downloadPath destination location for the file being downloaded
     */
    downloadIndividualFile(httpClientIndex, artifactLocation, downloadPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const stream = fs.createWriteStream(downloadPath);
            const client = this.downloadHttpManager.getClient(httpClientIndex);
            const requestOptions = utils_1.getRequestOptions('application/octet-stream', true);
            const response = yield client.get(artifactLocation, requestOptions);
            // check the response headers to determine if the file was compressed using gzip
            const isGzip = (headers) => {
                return ('content-encoding' in headers && headers['content-encoding'] === 'gzip');
            };
            if (utils_1.isSuccessStatusCode(response.message.statusCode)) {
                yield this.pipeResponseToStream(response, stream, isGzip(response.message.headers));
            }
            else if (utils_1.isRetryableStatusCode(response.message.statusCode)) {
                core_1.warning(`Received http ${response.message.statusCode} during file download, will retry ${artifactLocation} after 10 seconds`);
                // if an error is encountered, dispose of the http connection, and create a new one
                this.downloadHttpManager.disposeAndReplaceClient(httpClientIndex);
                yield new Promise(resolve => setTimeout(resolve, config_variables_1.getRetryWaitTimeInMilliseconds()));
                const retryResponse = yield client.get(artifactLocation);
                if (utils_1.isSuccessStatusCode(retryResponse.message.statusCode)) {
                    yield this.pipeResponseToStream(response, stream, isGzip(response.message.headers));
                }
                else {
                    // eslint-disable-next-line no-console
                    console.log(retryResponse);
                    throw new Error(`Unable to download ${artifactLocation}`);
                }
            }
            else {
                // eslint-disable-next-line no-console
                console.log(response);
                throw new Error(`Unable to download ${artifactLocation}`);
            }
        });
    }
    /**
     * Pipes the response from downloading an individual file to the appropriate stream
     * @param response the http response recieved when downloading a file
     * @param stream the stream where the file should be written to
     * @param isGzip does the response need to be be uncompressed
     */
    pipeResponseToStream(response, stream, isGzip) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                if (isGzip) {
                    // pipe the response into gunzip to decompress
                    const gunzip = zlib.createGunzip();
                    response.message
                        .pipe(gunzip)
                        .pipe(stream)
                        .on('close', () => {
                        resolve();
                    });
                }
                else {
                    response.message.pipe(stream).on('close', () => {
                        resolve();
                    });
                }
            });
        });
    }
}
exports.DownloadHttpClient = DownloadHttpClient;
//# sourceMappingURL=download-http-client.js.map